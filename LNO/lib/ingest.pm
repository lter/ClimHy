#! C:\Perl\bin\Perl  
use FindBin qw($Bin);

use strict;
use clim_lib;
use sql_cmd;
use FileHandle;
autoflush STDOUT 1;

# Kyle Kotwica 1-2003
# INGESTING ROUTINE FOR CLIMDB.

# Takes the output from harvest.pl and generates a file ready for processing 
# by the SQL scripts. This can also be called from the command line using 
# ingest.pl site. 

# If called from harvest, the log from the harvest routine will be 
# appended by the log generated by this file. The final output will be written
# into the data directory with the suffix .out . This program generates
# no HTML and does not use CGI. Its logfile is read by harvest.pl and is put
# into HTML. 
#
# This program requires a control file called climdb.conf. This file is 
# shared with all FUNDME modules and keeps variables that may change
# due to porting and what not. Make sure you can find the file! 
#
# NOTE TO MAINTAINER: In theory you should only have to change the 
# variables listed in climdb.cont to run
# this elsewhere. But in theroy you would think I could spel beter.
my (@args,$args,$site,%site,%research_site,%variables,%book,@QC_var);
#read control file 
my %control = &read_control();

my $dbh;

sub ingest{
	@args = @_;
	# we will use the $cmd_prompt flag to determine weather or not to overwrite
	# the $logfile, 'no' means we are running through the browser.
	my $cmd_prompt = 'no';
	if ($args[0] ne 'harvest'){
		$cmd_prompt = 'yes';}
	else{
		$args = shift;}
	
	$dbh = shift;
	
	
	#fill %variables with known	variables from climdb..variables
	%variables = &fill_variable_hash();
													
	while ($site = shift){
		$site = uc($site);

		# get all of stuff in the site table
		%site = &fill_site_hash();

		# open xxx.log xxx.out and xxx.in
		my $logfile = &open_files($cmd_prompt);
		
		
#site data will be [site,station,date]
#set it to 'start' the first time
		my $site_data = 'start';
		my $last_location = 'start';
		my $done = 0;
		my $bad_line = 0;
	
		my ($has_html,$continued,@header,$new_location);
	
#do some bookkeeping
		%book = &clear_book();
		print LOGFILE "$0 executed ".get_date()."\n\n$site\n";
		
		LINE: while (<INFILE>){	

			$book{line_num} += 1;
			
#get rid of garbage also check for continuation lines
			$done = &cleanUp(\$continued,$site_data,\$has_html);
			last LINE if $done;
			next LINE if $continued;
			
#if we get a blank line, count it and get another
			if(length($_) == 0){
				$book{blanks} += 1;
				next LINE;	
			}
			
#if no header was supplied.....assume one.
			if (($#header == -1) && (!/^!/)){
				$book{warnings}++;
				my $fake_header = &add_header();
				($done,@header) = &process_header($site_data,$fake_header);	
				$new_location = 1;
			}
					
#if its a header line...deal with it.
			elsif (/^!/){
				($done,@header) = &process_header($site_data,$_);
				$new_location = 1;
			}
	
#if its data.....deal with it
			elsif (/^$site/) {
				($new_location,$done,$last_location,$site_data) = &process_data($last_location,$new_location,@header);
			}
# major oops!
			else {
				my $error_string = "FATAL ERROR(903) Unknown site code encountered in the data set at:";
				$done = &log_error($site_data,$error_string);
				$done = 1;
			}
	
# if we got more then a certin number of warnings (climdb.conf)in this file stop
			my $gee_whiz = $control{warning}; 
			if ($book{warnings} >= $gee_whiz) { 
				my $error_string = "FATAL ERROR(907) Stopped logging warnings after $gee_whiz warnings encountered; Process is aborted:";
				$done = &log_error($site_data,$error_string);
				$done = 1;
			}

# BAIL if $done, $done is set to 1 if there is something wrong with the data file.
			last LINE if $done;
	
#$bad_line is set to 1 if there is something wrong with that particular line.
			$bad_line = 0;
		}
		print LOGFILE "Finished with $site_data\n\n";
		close INFILE;
		close OUTFILE;
		print "\nData quality checking complete.<BR>\n";	
		my $ok = 1;

	#if no fatals proceed with the SQL
		if (($control{ingest}) && ($control{digest} == 1) && ($done != 1)) { 
			print "The central database is being populated.<BR> <I>This should take less than 2 minutes. You will be informed when this step is completed. You may close your browser or go to another page. A summary log and quality assurance errors/warnings will be presented to this browser, if it is left open.</I><P>";
			$ok = &digest('harvest', $dbh, $site);
		}
		else {
			print "<B>The central database is not being populated. This is either due to the settings of the configuration file or because of a fatal error. If you did not expect this contact the central database administrator.</B><P>";
		}
		if ($ok == 0) {
			print "<BR><B>The central database is not being populated. There is an unspecified error during the processing of your data. Please contact the database administrator.</B><P>";
			$book{errors} = -1;
		}

		if ($done == 1){
			$done = 0;
			$book{errors} = -1;
		}
		&prn_summary($site);
		close LOGFILE;
		if ($cmd_prompt eq 'yes'){
			open (LOGFILE,"<$logfile") or die "Can't open $logfile: $!\n";
			while (<LOGFILE>){
				print $_;}
			close LOGFILE;
		} 
	
	}
	if ($cmd_prompt eq 'yes'){
		$dbh->disconnect();}
}

#######
####### END MAIN
#######


## ADD_HEADER
## Add a dummy header if none exists

sub add_header{
	my $fake_header = "!LTER_SITE,STATION,DATE,DAILY_AIRTEMP_MEAN_C,FLAG_DAILY_AIRTEMP_MEAN_C,DAILY_AIRTEMP_ABSMAX_C,FLAG_DAILY_AIRTEMP_ABSMAX_C,DAILY_AIRTEMP_ABSMIN_C,FLAG_DAILY_AIRTEMP_ABSMIN_C,DAILY_PRECIP_TOTAL_MM,FLAG_DAILY_PRECIP_TOTAL_MM";
	
	print LOGFILE "\nWARNING(102): No header was supplied. Using assumed header of form:\n$fake_header\n";
	print LOGFILE "\nWARNING Please correct your file.\nAdd a correct header and resubmit the data.\n";
	return($fake_header);
}
	
## PRN_SUMMARY
## Print summary statistics

sub prn_summary{
	my @dupes;
	if ($control{digest} == 1) {
		open (SQLLOG,"./log/sql.log") or 
			print "Can't open ./log/sql.log: $!\n";
		while (<SQLLOG>) {
			if ($_ =~ /^You.*(\d)/) {
				$book{duplicates} = $1;}
			if ($_ =~ /^Duplicate at (.*)/) {
				push @dupes, ($_ =~ /^Duplicate at (.*)/);}
		}
		close SQLLOG;
	}

	$book{good_lines} = $book{good_lines}-$book{duplicates};
	my $extra_text = '';
	
	if ( ($book{errors} < $book{verbose}) && ($book{errors} != -1)) {
		$extra_text = "(first $book{errors} listed above)";}
	elsif($book{errors} == -1) {
		$book{errors} = 'Fatal';}
	else{
		$extra_text = "(first $book{verbose} listed above)";}
	
	if ($dupes[0]) {
		foreach my $duplicate (@dupes) {
			print LOGFILE "FATAL ERROR(906): Duplicate found\n";
			print LOGFILE "$duplicate\n";
		}
	}

	print LOGFILE <<END;

Summary of $site follows:
	ON INPUT:
		$book{line_num} lines read. 
		$book{blanks} blank lines. 
		$book{header_lines} header lines. 
	DURING PROCESS:
		$book{duplicates} duplicate errors raised.
		$book{errors} process errors raised. $extra_text
		$book{warnings} warnings raised. 
	ON OUTPUT:
		$book{good_lines} data points prepared for entry into centralized database.
END

if ($book{errors} eq 'Fatal') {
	print LOGFILE "\n\n\t\tDue to the fatal error listed above the database can not been updated.\n";}
}


## CLEAN_UP
## strip stuff you don't want

sub cleanUp{
	my ($continued,$site_data,$has_html)= @_;
	my ($error_string,$done);

#if line has HTML tags get rid of it and warn first time
	if (/<.*?>/ && !$$has_html){
		$error_string = "WARNING(103): File contains HTML. The first occurrence is at:";
		$$has_html = 1;
		$done = &log_error($site_data,$error_string);
	}
	if (/<.*?>/) {$_ = '';}

	s/\s+//g;						#get rid of multiple spaces
	tr/a-z/A-Z/;					#get rid of lower case letters
	tr/[\000-\037]+//;				#get rid of control characters

#look for continuation lines: if line ends in '\' and next line starts in '#'
	if ($$continued) {
		if (/^#/){
			s/^#//;
			$_ = $$continued . $_;
			if (!/\\$/) {undef $$continued;}
		}elsif (/\\$/) {
			chop;
			$_ = $$continued . $_;
		} else {
			$error_string = "FATAL ERROR (905): Continuation line not continued.";
			$done = &log_error($site_data,$error_string);
			$book{errors} = -1;
			$done = 1;
		}
	}
	if ( (/\\$/) && (!/^#/) ){
		chop;
		$$continued = $_;
	}
	return($done);
}

######	PROCESS_DATA
###	the default argument ($_) looks something like this:
###	AND,PRIMET,19960102,5.3,,10.6,Q,0.8,,4.3,
#
sub process_data{
	my ($last_location,$new_location,@header) = @_;
	my ($done,$bad_line);
	
#add a 'G' for lines that end in ",". This is just for looks
	s/,$/,G/;

	my @fields = split(/,/,$_);

#get some descriptive data
	my $site_data = join ',',@fields[0..2];	

# check for site/station changes 

	($done,$new_location) = &research_site_check($new_location,$site_data,$last_location,$fields[1]);
	
# exit if error
	return($new_location,$done,$last_location,$site_data) if $done;
	
#check for errors 
	($done,$bad_line,@fields) = &QC($#header,$site_data,@fields);
#do rule based QC
	if (!$done) {&rules_QC($site_data,\@fields,\@header);}

#get next line or quit if error is critical	
	if ($done || $bad_line) {
		return($new_location,$done,$last_location,$site_data);
	}

#if not print it out
	for(my $i=3; $i<$#fields; $i=$i+2){
# If the data is good and we recognize it print it out; if not forget it
		if (($fields[$i+1] ne '!') && ($variables{$header[$i]})) {
			if ($fields[$i] =~ /(.........)\d+/) {
				$fields[$i] = $1;
			}
			print OUTFILE "$research_site{res_site_id},$research_site{site_id},$site_data,$variables{$header[$i]},$fields[$i],$fields[$i+1]\n";
			$book{good_lines}++;
		}
	}
	$last_location = $research_site{res_site_code};
	
	return('0','0',$last_location,$site_data);
}

## RESEARCH_SITE_CHECK
# here we check for site consistency 
# check to see if site_code (AND) exist
# check to see if either site_code or res_site_code (PRIMET) changes during possessing
# Also get res_site_id and site_id for harvest_raw(xxx.out) for the new schema
	
sub research_site_check {
	my ($new_location, $site_data, $last_location, $res_site_code) = @_;
	my $done;
	if($new_location){
		print LOGFILE "Started with $site_data\n";	
		&fill_research_site_hash($res_site_code,$site_data);
		&get_QC();					#get QC_var
	}

# check to see if the research site code is real
# no need to query the data base every time	
	if (($last_location ne 'start') && (uc($res_site_code) ne uc($last_location))) {
		&fill_research_site_hash($res_site_code,$site_data);
		if (!$research_site{res_site_code}){
			my $error_string = "FATAL ERROR(904) Unknown station code encountered in the data set at:";
			$done = &log_error($site_data,$error_string);
			$done = 1;	
			return ($done,$last_location);
		}
	}

# check to see if the research site code changed without warning
# $new_location should == 1 if we just read a header
			#($res_site_code != $last_location) )
	if (($new_location != 1) && ($res_site_code ne $last_location) && ($last_location ne 'start')){
		if (uc($last_location) !~ /$res_site_code/) {
			print LOGFILE "Finished with $last_location\n\n";
			my $error_string = "WARNING(107) Station code changed without a corresponding header change at :";
			$done = &log_error($site_data,$error_string);
			print LOGFILE "Started with $site_data\n";	
			&get_QC();				#get QC_var
		}
	}

	$new_location = 0;							#reset flag
	$last_location = uc($res_site_code);
	return ('0',$last_location);
}

## GET_QC 
## get default qc variables  (from climdb_variables) here
## also check for and get site specific qc variables (from 
## research_site_descriptor). If you got them use them, if not go back to 
## default QC values

sub get_QC(){

# get defaults
	my $sqlcmd = &get_cmd('14');
	@QC_var = &query_DB($sqlcmd,'array',$dbh);

#substitute site specific QC values, if we got 'em
	#loop threw each known variable in climdb_variables and query db for
	#site specific qc_min and qc_max
	for (my $j=0; $j<$#QC_var; $j=$j+4){
		my ($qc_min,$qc_max);
		$qc_min = &get_site_qc('qc_min',$QC_var[$j+3]);
		$qc_min =~ s/\s//g;
		$qc_max = &get_site_qc('qc_max',$QC_var[$j+3]);
		$qc_max =~ s/\s//g;
		if ($qc_min ne ''){	
			$QC_var[$j+1] = $qc_min;}
		if ($qc_max ne ''){
			$QC_var[$j+2] = $qc_max;}
	}
}

## GET_SITE_QC
# given a string (either qc_min or qc_max) query the database for that value

sub get_site_qc(){
	my ($what,$category) = @_;
	my $sqlcmd = &get_cmd('15',$what,$category,$research_site{res_site_id});
	my ($value,$name) = &query_DB($sqlcmd,'array',$dbh);
	if (!$value){$value = ' ';}
	return ($value);
}

#### RULES_QC 
## do rules based QC here

sub rules_QC(){
	my ($site_data,$fields,$header) = @_;
	my @air;
	my @soil;

# for each variable
	for(my $i=3; $i<$#$fields; $i = $i+2){
	
		next if (!$variables{$header->[$i]});
		next if $fields->[$i+1] eq '!';
# loop threw each set of QC_RULES variables
		for (my $j=0; $j<$#QC_var; $j=$j+4){	
		    my $test_var = $QC_var[$j];					# i.e. TMIN
			my $min_limit = $QC_var[$j+1];				# i.e. -45
			my $max_limit = $QC_var[$j+2];				# i.e. 50
			my $category_id = $QC_var[$j+3];					# i.e. 1
									# if we have a QC_RULES variable
			if ($variables{$header->[$i]} eq $test_var){
#run limits test
				&test_it($site_data,$test_var,$fields->[$i],$min_limit,$max_limit);
				@air = &save_it('T',$fields->[$i],$test_var,@air);
				@soil = &save_it('S',$fields->[$i],$test_var,@soil);
			}
		}
	}
	&min_max($site_data,@air);
	&min_max($site_data,@soil);
}

## MIN_MAX
# checks for min<mean<max

sub min_max(){
	my ($site_data,@value) = @_;
	my ($min,$max,$mean) = @value;
	my $error = 0;
	my $done = 0;
	
	if (($min) && ($mean)) {	
		if ($min > $mean)  {$error = 1;}
	}
	if (($min) && ($max)) {
		if ($min > $max) {$error = 1;} 
	}
	if (($max) && ($mean)) {	
		if ($mean > $max) {$error = 1;}
	}
	if ($error == 1) {
		my $error_string = "WARNING(106): Failed (min < mean < max) relationship at:";
		$done = &log_error($site_data,$error_string);
	}
}

## SAVE_IT
## save min max and mean for rule [min <= mean <= max]

sub save_it{
	my ($letter,$value,$test_var,@letter) = @_;
	my $min = $letter . 'MIN';
	my $mea = $letter . 'MEA';
	my $max = $letter . 'MAX';
#e.g. $test_var = 'SMIN', $min = 'SMIN', $value = 12
	if ($value){
		if ($test_var eq $min) {
			$letter[0] = $value; 
		}
		if ($test_var eq $max) {
			$letter[1] = $value;
		}
		if ($test_var eq $mea) {
			$letter[2] = $value;
		}
	}
#@letter = [min,max,mea] where min,max, and mea are the values for 
#the $letter variable. i.e. tmin,tmea,tmax
	return (@letter);
}


## QC 
# do quality control (called by process_data)
# this returns ($done,$bad_line,@fields)
# $done = 1 means your done fatal error.
# $bad_line = 1 means this line cant be dealt with.

sub QC{
	my ($header,$site_data,@fields) = @_;
	my $error_string;
	my $done = 0;

#bail if they forgot the header
#This should never happen test and remove.
	if ($header == 0){		
		$error_string = "ERROR(006): No Header in file $site. ";
		$done = &log_error($site_data,$error_string);
		return($done,1,@fields);
	}

#if you don't have an odd number of data you must have a problem
	if ($#fields%2 != 0){
		$error_string = "ERROR(005): Illegal number of data fields at:";
		$done = &log_error($site_data,$error_string);
		return($done,1,@fields);
	}

#if the number of data do not match the number of headers you have a problem
	if ($#fields != $header){
		$error_string = "ERROR(001): Number of data fields($#fields) != number of header fields($header) at:";
		$done = &log_error($site_data,$error_string);
		return($done,1,@fields);
	}

	for(my $i=3; $i<$#fields; $i = $i+2){
#if flag is 'T' and data = null then flag is set to 'M'
		if (!defined($fields[$i+1])){		#we will catch this error elsewhere
											#ignore it for now.
			$fields[$i+1] = '';
		}

		if ($fields[$i+1] eq 'T' && $fields[$i] eq ''){
			$fields[$i+1] = 'M';
			$fields[$i] = '';
			$error_string = "WARNING(104): Flag = T ; data = null. Flag set to 'M' at:"; 
			$done = &log_error($site_data,$error_string);
		}

#if data field is null make flag = 'M'
		if ($fields[$i] eq ''){
			$fields[$i+1] = 'M';}

#check to see if data is numeric
		if (!($fields[$i] =~ /^(-?\d+\.?\d*|-?\.\d+)$/) && !($fields[$i+1] =~ /M/)){
			$error_string = "ERROR(003): $fields[$i] is not valid (must be numeric) at:";
			$fields[$i+1] = '!';
			$done = &log_error($site_data,$error_string);
			return($done,0,@fields);
		}

#check for unknown flags. We only know of G,E,Q,M,C,V and T.
		if ($fields[$i+1] =~ /[^!GEQMTCV]/){
			$error_string = "ERROR(002): Flag character $fields[$i+1] not recognized at:";
			$fields[$i+1] = '!';
			$done = &log_error($site_data,$error_string);
			return($done,0,@fields);
		}

			
		if ($fields[$i+1] ne "!"){		#don't print if data is bad
			if ($fields[$i+1] eq '')		#fill in blank flags with 'G'
				{$fields[$i+1]='G';}			#this is just for looks
#if ($fields[$i] =~ /999.0/)		#if data = 9999 
#	{$fields[$i+1]='M';}			#set flag to 'M'
			if ($fields[$i] eq 9999)		#if data = 9999 
				{$fields[$i+1]='M';}			#set flag to 'M'
			if ($fields[$i+1] eq 'M')		#if flag = 'M' 
				{$fields[$i]='';}				#set data to null
		}
	}
		
#check date
	my $data_year = substr($fields[2],0,4);
	my $data_month = substr($fields[2],4,2);
	my $data_day = substr($fields[2],6,2);
	if ($fields[2] > get_date('today_code')){
		$error_string ="ERROR(004): Time stamp $fields[2] is in the future at:";
		$done = &log_error($site_data,$error_string);
		return($done,1,@fields);
	}
	elsif ($data_year<1869){
		$error_string = "WARNING(105): (Year<1869) Year is $data_year at:";
		$done = &log_error($site_data,$error_string);
	}
	elsif (($data_month<1)||($data_month>12)){
		$error_string = "ERROR(004): Month can not be $data_month at:";
		$done = &log_error($site_data,$error_string);
		return($done,1,@fields);
	}
	elsif (($data_day<=0)||($data_day>31)){
		$error_string = "ERROR(004): Day can not be $data_day at:";
		$done = &log_error($site_data,$error_string);
		return($done,1,@fields);
	}
	elsif (($data_day>29)||($data_day<32)){
		if ( ($data_month == 4)
				|| ($data_month == 6)
				|| ($data_month == 9)
				|| ($data_month == 11) ) {
				
			if ($data_day == 31) {
				$error_string = "ERROR(004): Day can not be $data_day at:";
				$done = &log_error($site_data,$error_string);
				return($done,1,@fields);
			}
		} elsif ($data_month == 2) {
			if (($data_year % 4) != 0) {	
				if ($data_day == 29) {
					$error_string = "ERROR(004): Day can not be $data_day at:";
					$done = &log_error($site_data,$error_string);
					return($done,1,@fields);
				}
			}
		}
	}
	else{}
	return($done,0,@fields);
}

##### LOG_ERROR
## Log error takes an error string and site data and prints it.

sub log_error{
	my ($site_data,$error_string) = @_;
	my $done = 0;
	if ($error_string =~ /^E/){
		$book{errors}++;}
	elsif ($error_string =~ /^W/){
		$book{warnings}++;
	}
	if ($book{errors} < 0){
		print LOGFILE ("$error_string\n\t \t\tinput file ($site) line $.\n\n");
		print LOGFILE ("Can not process. Exiting file\n");
	}
# if we got more then 'verbose' errors in this file stop
	if (($book{errors} == $book{verbose}) && ($book{verbose} > 0)){
		print LOGFILE ("$error_string\n\t $site_data\t input file ($site) line $.\n\n");
		print LOGFILE "FATAL ERROR:(902) Stopped logging errors after $book{verbose} errors encountered; Process is aborted:\n";
		$done = 1;
	}
	else{
		print LOGFILE ("$error_string\n\t $site_data\t input file ($site) line $.\n\n");
	}
	return($done);
}

##### GET_DATE
## Just get todays date

sub get_date{
	my $today_code = shift;

	my @today = localtime(time);
	my $year = $today[5];
	my $month = $today[4] + 1;
	my $day = $today[3];
	if($month < 10){
		$month = "0".$month;}
	if($today[3] < 10){
		$day = "0".$day;}
	if($year >= 0 && $year <=50){
		$year += 2000;}
	else{
		$year += 1900;}

	if($today_code){
		my $today_code = $year.$month.$day;}
	else{
		my $today = $month.'/'.$day.'/'.$year;}
}
	
##### PROCESS_HEADER
##	The default argument ($_) looks something like this:
##	!lter_site, Station, Date, Daily_AirTemp_Mean_C, Flag_Daily_AirTemp_Mean_C,Daily_AirTemp_AbsMax_C,Flag_Daily_AirTemp_AbsMax_C,Daily_AirTemp_AbsMin_C,Flag_Daily_AirTemp_AbsMin_C,Daily_Precip_Total_mm,Flag_Daily_Precip_Total_m
	
sub process_header{
	my ($site_data,$header) = @_;
	my $done = 0;
	if($site_data ne 'start'){	
		print LOGFILE "Ended with $site_data\n";
	}
	my @header = split(/,/,$header);			#put header into a list

#check to see if we have been sent any new variables
	&check_var($site_data,@header);

#Check to make sure that data is followed by flag_data
HEADER:
	for (my $i=3;$i<@header;$i = $i+2){
		my $test = $header[$i+1]; 			#$test should be 'FLAG_X'
		$test =~ s/FLAG_?//;				#$test should now be 'X'
		if ($header[$i] ne $test){			#if it isn't complain
			my $error_string = "FATAL ERROR(901): $header[$i] needs to be followed by FLAG_$header[$i] at:";
			$done = 1;
			$book{errors} = -1;
			$done = &log_error($site_data,$error_string);
			last HEADER if ($book{errors} == -1);
		}
	}
	$book{header_lines}++;
	return ($done,@header);
}


##### CHECK_VAR
# this checks to see if they threw a new variable at you that you never saw
# before.

sub check_var{
	my ($site_data,@header) = @_;
	my ($name,$match,$key,$error_string,$old_name);
	my $done = 0;

	foreach $name (@header){				#variables in file header
		$match = 0;
		if ($name eq '!LTER_SITE' || $name eq 'STATION' || $name eq 'DATE' || $name =~ /^FLAG/)									#ignore if unimportant
			{next;}
		$old_name = $name;
		foreach $key (keys %variables){				#previously known variables
# take name from header compare to key from DB; after removing underscores and
# capitalizing
			$key =~ s/_//g;
			$name =~ s/_//g;
			$key =~ tr/[a-z]/[A-Z]/;
			$name =~ tr/[a-z]/[A-Z]/;
			if ($name eq $key){					#if we recognize it
				$match = 1;
				last;								#go on
			}

		}
		if ($match == 0){
			$error_string ="WARNING(100): Ignoring unknown variable $old_name at:";
			$done = &log_error($site_data,$error_string);
		}
	}
}

### TEST_IT
## Test QC default/metadata limits 

sub test_it{
	my ($site_data,$test_var,$test_value,$min_limit,$max_limit) = @_;
	my $done=0;

	if ($test_value ne ''){ 
		if ($test_value < $min_limit || $test_value > $max_limit) {
			my $error_string = "WARNING(101): $test_var = $test_value (min=$min_limit max=$max_limit) failed QC test at:";
			$done = &log_error($site_data,$error_string);
		}
	}	
}

#### FILL_VARIABLE_HASH
# fill %variables hash table with known variables from climdb_variables

sub fill_variable_hash(){
	my $sqlcmd = &get_cmd('11');
	return(&query_DB($sqlcmd,'hash',$dbh));
}

# fill %site hash table with contents of site table.

sub fill_site_hash() {
	my $sqlcmd = &get_cmd('12',$site);
	my @huh = &query_DB($sqlcmd,'array',$dbh);
	%site = (
		site_id => $huh[0],
		site_name => $huh[1],
		hydro_data_url => $huh[2],
		clim_data_url => $huh[3],
		usgs_data_url => $huh[4],
		site_code => $huh[5]
	);
}

# fill %research_site hash table with contents of research_site table.

sub fill_research_site_hash() {
	my $res_site_code = shift;
	my $sqlcmd = &get_cmd('13',$res_site_code,$site{site_id});
	my @huh = &query_DB($sqlcmd,'array',$dbh);
	%research_site = (
		res_site_id => $huh[0],
		res_sitetype_id => $huh[1],
		res_site_code => $huh[2],
		site_id => $huh[3]
	);
}

sub clear_book {
	%book = (
		warnings => 0,
		blanks => 0,
		errors => 0,
		line_num => 0,
		header_lines => 0,
		good_lines => 0,
		duplicates => 0,
		verbose => $control{verbose},
	);
}

sub open_files {
	my $cmd_prompt = shift;
	my $outfile = "$Bin/data/". substr($site,0,3).".out";
	open (OUTFILE,">$outfile") or die "Can't open $outfile: $!\n";
	my $logfile = "$Bin/log/" . substr($site,0,3).".log";
	if ($cmd_prompt eq 'yes'){
		open (LOGFILE,">$logfile") or die "Can't open $logfile: $!\n";}
	else{
		open (LOGFILE,">>$logfile") or die "Can't open $logfile: $!\n";}
	print LOGFILE "\n\nBeginning QA procedures...\n";
	my $datfile = "$Bin/data/" . substr($site,0,3).".in";
	open (INFILE,"<$datfile") or die "Can't open $datfile: $!\n";
	return $logfile;
}

1; 
